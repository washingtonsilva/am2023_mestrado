---
title: "Tutorial: Modelos de RegressãO Linear"
output: html_notebook
---

<style type="text/css">
  body{
  font-size: 12pt;
  text-align: justify
      }
</style>


# Regressão Linear Simples em R 


## Aplicação: Razão Ótima de Hedge - Brooks (2019).

Embora existam muitas técnicas disponíveis para reduzir e gerenciar riscos, 
a mais simples e talvez a mais utilizada é o hedge com contratos futuros. 

Um hedge é obtido assumindo posições opostas nos mercados à vista (spot) e de 
futuros, simultaneamente, de modo que uma perda sofrida por um movimento adverso 
de preço em um mercado pode ser eliminada (ou reduzida) em algum grau por um 
movimento favorável de preço no outro. 

A relação entre o número de unidades do ativo futuro que são compradas em 
relação ao número de unidades do ativo à vista é conhecida como 
**razão de hedge**. 

Como o risco neste contexto é geralmente medido como a volatilidade dos 
retornos da carteira, uma estratégia intuitivamente plausível pode ser 
escolher a razão íde hedge que minimiza a variação dos retornos de 
uma carteira contendo a posição à vista e futura; isso é conhecido como a 
razão ótima de hedge.

Seja $\Delta S$ a variação no preço à vista, $S$, durante a vida do hedge. 
$\Delta F$ a variação no preço futuro, $F$, durante a vida do hedge. $\sigma_S$ 
o desvio-padrão de $\Delta S$, $\sigma_F$ o desvio-padrão de $\Delta F$ e 
$\rho$ o coeficiente de correlação entre $\Delta S$ e $\Delta F$ e $h$ a 
razão de hedge.

Para um hedge curto (ou seja, posição longa no ativo e curta em contratos 
futuros) a variaçaõ no valor da posição do "hedger" durante a vida do 
hedge será dada por $(\Delta S - h \Delta F)$, enquanto para um hedge longo, 
a expressão é $(h \Delta F - \Delta S)$. Assim, as variâncias das duas 
carteiras hedgeadas são as mesmas e podem ser obtidas por:

$$
\begin{align*}
V(\Delta S - h \Delta F) &= V(\Delta S) + V(h \Delta F) - 2Cov(\Delta S, h \Delta F), \\
                         &= V(\Delta S) + h^2V(\Delta F)) - 2hCov(\Delta S, \Delta F), \\
                         &= \sigma_{S}^2 + h^2\sigma_{F}^2 - 2h\rho\sigma_S \sigma_F
\end{align*}
$$

Minimizando $V(\Delta S - h \Delta F)$ em relação à h, obtemos:

$$
h^{\ast} = \frac{Cov(R_s, R_F)}{V(R_F)} = \rho \frac{\sigma_{S}}{\sigma_{Fs}}
$$

Que equivale à correlação entre $R_S$ e $R_F$ e, no caso do modelo de 
regressão linear simples, equivale à $\beta_1$. De acordo com esta derivação, a 
razão ótima de hedge é invariante no tempo e pode ser calculada usando dados 
históricos dos retornos. Isto é, esta derivação da razão ótima de hedge indica 
que podemos estimar $h^{\ast}$ pela estimação de $\beta_1$ do seguinte 
modelo de regressão linear simples:

$$
\hat{r}_{spot} = \hat{\beta}_0 + \hat{\beta}_1 r_{futuro} 
$$

Neste caso de Brooks (2019), um investidor deseja proteger uma posição longa 
no índice S&P500 (ou suas ações constituintes) usando uma posição curta em 
contratos futuros. O investidor está interessado na razão ótima de hedge, 
ou seja, o número de unidades do ativo futuro a serem vendidas por unidade 
dos ativos à vista mantidos.

Neste tipo de aplicação, estamos geralmente mais interessados na qualidade 
do ajuste do modelo aos dados, isto é, em sua capacidade explicativa 
da variável resposta $y$ e nas estimativas de determinados parâmetros que 
tem um significado específico determinado pela teoria subjacente, no caso, 
estamos interessados na estimativa da razão ótima de hedge por $\hat{\beta}_1$.


## 1. Pacotes Necessários

```{r, warning=FALSE, message=FALSE}
library(here)
library(readxl)
library(janitor)
library(dplyr)
library(tidymodels)
library(vip)         # para importancia das variaveis
```


## 2. Dados

Vamos utilizar a função `read_excel()` do pacote `readxl` para importar o 
arquivo `SandPhedge.xls` disponibilizado por Brooks (2019). Este arquivo 
contém os níveis de preço mensais para o índice índice S\&P(500) , à vista, e 
para o índice S\&P(500) futuro.

```{r}
# Definindo o endereco do arquivo
path_xls <- here("data_raw", "SandPhedge.xls")

hedge <- readxl::read_xls(path_xls)

# visualizando a estrutura dos dados
glimpse(hedge)
```


## Preparação dos Dados

A função `clean_names()` do pacote `janitor` é muito útil para definir de 
forma automatizada nomes adequados para as variáveis:

```{r}
hedge <- hedge %>% clean_names()
glimpse(hedge)
```

Executaremos nossa análise com base nos retornos do índice S&P500 em vez dos 
níveis de preços. Assm o próximo passo é transformar as séries de preços 
`spot` e `future` em retornos percentuais. Vamos usar retornos compostos 
continuamente, ou seja, retornos logarítmicos, em vez de retornos simples como 
é comum em pesquisas acadêmicas: 

$$
r_t = \ln(1 + R_t) = \ln\Bigl(\frac{P_t}{P_{t-1}}\Bigr) = 100\times(\ln(P_t) - \ln(P_{t-1}))
$$

O códig a seguir, além de calcular os retornos, elimina os dados faltantes dos 
dados:

```{r}
# calculando os retornos
hedge <- hedge %>%
  dplyr::transmute(
    rspot = c(NA, 100*diff(log(spot))),
    rfutures = c(NA, 100*diff(log(futures))),
  )

dplyr::glimpse(hedge)
```


```{r}
# eliminando os dados faltantes (linhas)
hedge_clean <- na.omit(hedge)

# visao geral do objeto
dplyr::glimpse(hedge_clean)
```



